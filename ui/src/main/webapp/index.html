<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>SmIRCd Client</title>
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Ubuntu">
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Droid+Sans">
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Droid+Sans+Mono">
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.2.0/build/cssreset/reset-min.css">
    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.4.4/jquery.min.js"></script>
    <style>
      body {
        font-family: 'Droid Sans';
      }

      body > div {
        position: fixed;
        width: 100%;
        padding: 0 0.25em 0 0.25em;
        overflow: auto;
      }

      body > div:first-child, body > div:last-of-type {
        height: 2em;
        line-height: 2em;
        -webkit-box-shadow: 0 0 16px #333;
        background: #1C4A72;
      }

      body > div:first-child { top: 0; }
      body > div:last-of-type { bottom: 0; }

      h1, h2, h3 {
        font-family: 'Ubuntu';
      }

      h1, h1 + h2, h2 + h2 {
        float: left;
        color: white;
      }

      h1 + h2, h2 + h2 {
        display: none;
      }

      h2:before {
        padding: 0 0.25em 0 0.25em;
        color: #EB8900;
        content: '>';
      }

      input {
        width: 100%;
        border: 1px solid #353B41;
        border-radius: 5px;
        background: #eee;
      }

      .transcript {
        top: 2em;
        bottom: 2em;
        border-top: 1px solid #353B41;
        border-bottom: 1px solid #353B41;
        line-height: 1.25em;
      }

      .transcript p {
        margin-bottom: 0.5em;
      }

      .chatMsg {
        margin-left: 9em;
      }

      .chatMsg.backgroundChannel {
        opacity: 0.5;
      }

      .chatMsg h3 {
        display: inline;
        margin-right: 1em;
        margin-left: -9em;
        color: #777;
      }

      .chatMsg.private h3 {
        color: #EB8900;
      }

      .chatMsg h3:before {
        margin-right: 1em;
        content: attr(date);
      }

      .chatMsg h3 + p {
        display: inline;
      }

      .event, .action, .error {
        color: #666;
        font-family: 'Droid Sans Mono';
      }

      .event:before, .action:before, .error:before {
        padding-right: 0.25em;
        content: '***';
      }

      .action {
        font-style:italic;
      }

      .error {
        color: #A61300;
      }

      .welcome {
        background: #ddd;
        border: 2px solid #ddd;
        border-radius: 10px;
        margin: 1em;
        padding: 0.25em 1em 0.25em 1em;
      }

      .systemMsg {
        border-left: 2px solid #1C4A72;
        background: #eee;
        padding: 0.25em;
        margin-bottom: 0.5em;
      }

      .systemMsg td, th {
        padding-right: 1em;
      }

      .command {
        color: #666;
        font-family: 'Droid Sans Mono';
      }

      .nick {
        background: #FFBB00;
        border: 2px solid #FFBB00;
        border-radius: 5px;
      }

    </style>
  </head>
  <body>
    <div>
      <h1>SmIRCd Client</h1>
      <h2 id="connectionInfo"><script type="text/html" id="connectionInfoTmpl">Connected to <%= host %>:<%= port %> as <%= nickname %></script></h2>
      <h2 id="channelInfo"><script type="text/html" id="channelInfoTmpl">In channel <%= channel %></script></h2>
    </div>
    <div class="transcript">
      <div class="welcome">
        <h2>SmIRCd Client</h2>
        <p>
        Welcome to IRC!
        To get started, type <span class="command">/CONNECT &lt;nickname&gt; [&lt;password&gt;] [@&lt;server&gt;]</span>.
        Once connected, join a channel with <span class="command">/JOIN &lt;#channelname&gt;</span> or see the available channels with <span class="command">/LIST</span>.
        You can type <span class="command">/HELP</span> at any time.
        </p>
      </div>

      <script type="text/html" id="systemMsgTmpl">
        <div class="systemMsg"><%= msg %></div>
      </script>

      <script type="text/html" id="eventMsgTmpl">
        <div class="event"><%= msg %></div>
      </script>

      <script type="text/html" id="chatMsgTmpl">
        <div class="chatMsg <%= msgType %>">
          <h3 date="<%= msgDate %>"><%= msgSender %></h3>
          <p><%= message %></p>
        </div>
      </script>

      <script type="text/html" id="errorMsgTmpl">
        <p class="error"><%= msg %></p>
      </script>

      <script type="text/html" id="commandHelpTmpl">
        <h2>SmIRCd Client Help: <%= cmdName %> command</h2>
        <p>Usage: /<%= cmdName %> <%= usage %></p>
        <p><%= detailed %></p>
      </script>

      <script type="text/html" id="helpTmpl">
        <h2>SmIRCd Client Help</h2>
        <p>Use /HELP [command] to get more information about a specific command</p>
        <table>
          <% $.each(cmds, function(key, value) { %>
            <tr><td><%= key %></td><td><%= value.help.quick %></td></tr>
            <% }); %>
        </table>
      </script>

      <script type="text/html" id="motdTmpl">
        <h2>Message of the Day</h2>
        <% $.each(buffer, function(idx, msg) { %>
          <p><%= msg %></p>
        <% }); %>
      </script>

      <script type="text/html" id="listTmpl">
        <h2>Channel list</h2>
        <table>
          <tr><th>Channel</th><th>Count</th><th>Is Member?</th><th>Topic</th></tr>
          <% $.each(buffer, function(idx, chan) { %>
            <tr>
              <td><%= chan.name %></td>
              <td><%= chan.count %></td>
              <td><%= chan.isMember %></td>
              <td><%= chan.topic %></td>
            </tr>
          <% }); %>
        </table>
      </script>

      <!--
      <p class="action">someone shrugs</p>
      -->
    </div>
    <div>
      <form>
        <input type="text" autofocus placeholder="Enter a command then press enter...">
      </form>
    </div>
    <script>
      // Simple JavaScript Templating
      // John Resig - http://ejohn.org/ - MIT Licensed
      (function(){
        var cache = {};

        this.tmpl = function tmpl(str, data){
          // Figure out if we're getting a template, or if we need to
          // load the template - and be sure to cache the result.
          var fn = !/\W/.test(str) ?
            cache[str] = cache[str] ||
              tmpl(document.getElementById(str).innerHTML) :

            // Generate a reusable function that will serve as a template
            // generator (and which will be cached).
            new Function("obj",
              "var p=[],print=function(){p.push.apply(p,arguments);};" +

              // Introduce the data as local variables using with(){}
              "with(obj){p.push('" +

              // Convert the template into pure JavaScript
              str
                .replace(/[\r\t\n]/g, " ")
                .split("<%").join("\t")
                .replace(/((^|%>)[^\t]*)'/g, "$1\r")
                .replace(/\t=(.*?)%>/g, "',$1,'")
                .split("\t").join("');")
                .split("%>").join("p.push('")
                .split("\r").join("\\'")
            + "');}return p.join('');");

          // Provide some basic currying to the user
          return data ? fn( data ) : fn;
        };
      })();
    </script>

    <script>
      var splitToken = function(s) {
        if (!s) {
          return [null, null];
        }

        s = $.trim(s);
        var index = s.search(/\s+/);
        if (s.length == 0) {
          return [null, null];
        }
        else if (index == -1) {
          return [s, null];
        }
        else {
          return [s.substring(0, index), $.trim(s.substring(index))];
        }
      };

      var firstToken = function(s) { return splitToken(s)[0]; };

      var makeSafe = function(unsafe) {
        switch ($.type(unsafe)) {
          case 'array':
            return $.map(unsafe, function(el) { return makeSafe(el); });
          case 'object':
            var safe = {};
            $.each(unsafe, function(name, val) {
              safe[makeSafe(name)] = makeSafe(val);
            });
            return safe;
          case 'string':
            return $(document.createElement('div')).text(unsafe).html();
          default:
            throw $.type(unsafe) + " value " + unsafe + " can not be made safe";
        }
      };

      var subscribe = function(evtName, callback) {
        $(document).bind(evtName, function(evt, evtData) {
          callback(evtData);
        });
      };

      var publish = function(evtName, evtData) {
        console.log("Firing " + evtName + " event");
        $(document).trigger(evtName, evtData);
      };

      var channelManager = (function() {
        var activeChannels = [];

        var _modifyChannels = function(toRemove, toAdd) {
          var previousChannel = public.currentChannel();

          var idx = activeChannels.indexOf(toRemove);
          if (idx != -1) {
            var removed = activeChannels.splice(idx, 1);
            console.log("Removed " + removed + " from active channel list");
          }

          if (toAdd) {
            activeChannels.unshift(toAdd);
            console.log("Updated active channel list is " + activeChannels);
          }

          var newChannel = public.currentChannel();
          if (newChannel != previousChannel) {
            console.log("Active channel has changed from " + previousChannel + " to " + newChannel);
            publish("currentChannelChanged", {
              previousChannel:  previousChannel,
              channel: newChannel
            });
          }
        };

        subscribe("joinedChannel", function(chan) {
          console.log("Joined channel " + chan);
          _modifyChannels(chan, chan);
        });

        subscribe("leftChannel", function(chan) {
          console.log("Left channel " + chan);
          _modifyChannels(chan);
        });

        var public = {
          currentChannel: function() {
            return (activeChannels.length > 0)? activeChannels[0] : null;
          },

          isMember: function(channelName) {
            return $.inArray(channelName, activeChannels) != -1;
          }
        };

        return public;
      })();

      var ircServer = (function() {
        var currentNickname = null;
        var ircSocket = null;
        var connected = false;

        var _getHostPort = function(str) {
          var parts = str.split(":");
          switch (parts.length) {
            case 1: return { host: parts[0], port: 6667 };
            case 2: return { host: parts[0], port: parseInt(parts[1]) };
            default: return { host: '', port: NaN };
          }
        };

        var _toIrcCommandString = function(args) {
          if (args.length > 1) {
            var lastArg = args[args.length - 1];
            if (lastArg == "") {
              args[args.length - 1] = ":";
            }
            else if (lastArg.indexOf(" ") >= 0) {
              args[args.length - 1] = ":" + lastArg;
            }
          }

          if (currentNickname) {
            args.unshift(":" + currentNickname);
          }

          return args.join(" ");
        };

        var _parseIrcCommandString = function(str, result) {
          result = result || {
            cmd: null,
            args: []
          };

          if (!str) {
            return result;
          }
          else if (!result.cmd) {
            var tokenAndRest = splitToken(str);
            if (!tokenAndRest[0]) {
              return result;
            }
            else if (tokenAndRest[0][0] == ":") {
              result.prefix = tokenAndRest[0].substring(1);
              return _parseIrcCommandString(tokenAndRest[1], result);
            }
            else {
              result.cmd = tokenAndRest[0];
              return _parseIrcCommandString(tokenAndRest[1], result);
            }
          }
          else if (str[0] == ":") {
            result.args.push(str.substring(1));
            return result;
          }
          else {
            var tokenAndRest = splitToken(str);
            if (!tokenAndRest[0]) {
              return result;
            }
            else {
              result.args.push(tokenAndRest[0]);
              return _parseIrcCommandString(tokenAndRest[1], result);
            }
          }
        };

        var _disconnect = function() {
          currentNickname = null;

          if (ircSocket) {
            console.log("Closing websocket");
            ircSocket.close();
            ircSocket = null;
          }
          else {
            console.log("Skipping websocket close");
          }

          if (connected) {
            console.log("Disconnecting from server");
            connected = false;
            publish("serverDisconnected");
          }
          else {
            console.log("Skipping disconnect, not connected");
          }
        };

        var public = {
          RC: {
            RPL_TRACELINK: "200",
            RPL_TRACECONNECTING: "201",
            RPL_TRACEHANDSHAKE: "202",
            RPL_TRACEUNKNOWN: "203",
            RPL_TRACEOPERATOR: "204",
            RPL_TRACEUSER: "205",
            RPL_TRACESERVER: "206",
            RPL_TRACENEWTYPE: "208",
            RPL_STATSQLINE: "209",
            RPL_STATSLINKINFO: "211",
            RPL_STATSCOMMANDS: "212",
            RPL_STATSCLINE: "213",
            RPL_STATSNLINE: "214",
            RPL_STATSILINE: "215",
            RPL_STATSKLINE: "216",
            RPL_TRACECLASS: "217",
            RPL_STATSYLINE: "218",
            RPL_ENDOFSTATS: "219",
            RPL_UMODEIS: "221",
            RPL_ENDOFSERVICES: "231",
            RPL_SERVICEINFO: "232",
            RPL_SERVLIST: "233",
            RPL_SERVICE: "234",
            RPL_SERVLISTEND: "235",
            RPL_STATSLLINE: "241",
            RPL_STATSUPTIME: "242",
            RPL_STATSOLINE: "243",
            RPL_STATSHLINE: "244",
            RPL_LUSERCLIENT: "251",
            RPL_LUSEROP: "252",
            RPL_LUSERUNKNOWN: "253",
            RPL_LUSERCHANNELS: "254",
            RPL_LUSERME: "255",
            RPL_ADMINME: "256",
            RPL_ADMINLOC1: "257",
            RPL_ADMINLOC2: "258",
            RPL_ADMINEMAIL: "259",
            RPL_TRACELOG: "261",
            RPL_NONE: "300",
            RPL_AWAY: "301",
            RPL_USERHOST: "302",
            RPL_ISON: "303",
            RPL_UNAWAY: "305",
            RPL_NOWAWAY: "306",
            RPL_WHOISUSER: "311",
            RPL_WHOISSERVER: "312",
            RPL_WHOISOPERATOR: "313",
            RPL_WHOWASUSER: "314",
            RPL_ENDOFWHO: "315",
            RPL_KILLDONE: "316",
            RPL_WHOISIDLE: "317",
            RPL_ENDOFWHOIS: "318",
            RPL_WHOISCHANNELS: "319",
            RPL_LISTSTART: "321",
            RPL_LIST: "322",
            RPL_LISTEND: "323",
            RPL_CHANNELMODEIS: "324",
            RPL_NOTOPIC: "331",
            RPL_TOPIC: "332",
            RPL_INVITING: "341",
            RPL_SUMMONING: "342",
            RPL_VERSION: "351",
            RPL_WHOREPLY: "352",
            RPL_NAMREPLY: "353",
            RPL_WHOISCHANOP: "361",
            RPL_CLOSEEND: "362",
            RPL_CLOSING: "363",
            RPL_LINKS: "364",
            RPL_ENDOFLINKS: "365",
            RPL_ENDOFNAMES: "366",
            RPL_BANLIST: "367",
            RPL_ENDOFBANLIST: "368",
            RPL_ENDOFWHOWAS: "369",
            RPL_INFO: "371",
            RPL_MOTD: "372",
            RPL_MYPORTIS: "373",
            RPL_ENDOFINFO: "374",
            RPL_MOTDSTART: "375",
            RPL_ENDOFMOTD: "376",
            RPL_YOUREOPER: "381",
            RPL_REHASHING: "382",
            RPL_INFOSTART: "384",
            RPL_TIME: "391",
            RPL_USERSSTART: "392",
            RPL_USERS: "393",
            RPL_ENDOFUSERS: "394",
            RPL_NOUSERS: "395",
            ERR_NOSUCHNICK: "401",
            ERR_NOSUCHSERVER: "402",
            ERR_NOSUCHCHANNEL: "403",
            ERR_CANNOTSENDTOCHAN: "404",
            ERR_TOOMANYCHANNELS: "405",
            ERR_WASNOSUCHNICK: "406",
            ERR_TOOMANYTARGETS: "407",
            ERR_NOORIGIN: "409",
            ERR_NORECIPIENT: "411",
            ERR_NOTEXTTOSEND: "412",
            ERR_NOTOPLEVEL: "413",
            ERR_WILDTOPLEVEL: "414",
            ERR_UNKNOWNCOMMAND: "421",
            ERR_NOMOTD: "422",
            ERR_NOADMININFO: "423",
            ERR_FILEERROR: "424",
            ERR_NONICKNAMEGIVEN: "431",
            ERR_ERRONEUSNICKNAME: "432",
            ERR_NICKNAMEINUSE: "433",
            ERR_NICKCOLLISION: "436",
            ERR_USERNOTINCHANNEL: "441",
            ERR_NOTONCHANNEL: "442",
            ERR_USERONCHANNEL: "443",
            ERR_NOLOGIN: "444",
            ERR_SUMMONDISABLED: "445",
            ERR_USERSDISABLED: "446",
            ERR_NOTREGISTERED: "451",
            ERR_NEEDMOREPARAMS: "461",
            ERR_ALREADYREGISTRED: "462",
            ERR_NOPERMFORHOST: "463",
            ERR_PASSWDMISMATCH: "464",
            ERR_YOUREBANNEDCREEP: "465",
            ERR_BADCHANMASK: "466",
            ERR_YOUWILLBEBANNED: "476",
            ERR_KEYSET: "467",
            ERR_CHANNELISFULL: "471",
            ERR_UNKNOWNMODE: "472",
            ERR_INVITEONLYCHAN: "473",
            ERR_BANNEDFROMCHAN: "474",
            ERR_BADCHANNELKEY: "475",
            ERR_NOPRIVILEGES: "481",
            ERR_CHANOPRIVSNEEDED: "482",
            ERR_CANTKILLSERVER: "483",
            ERR_NOOPERHOST: "491",
            ERR_NOSERVICEHOST: "492",
            ERR_UMODEUNKNOWNFLAG: "501",
            ERR_USERSDONTMATCH: "502"
          },

          connect: function(server, nickname, password) {
            _disconnect();

            server = server || (location.host || 'localhost')
            console.log("Connecting to " + server + " as " + nickname + " using password " + password);

            var hp = _getHostPort(server);
            if (hp.host.length == 0 || isNaN(hp.port)) {
              publishMsg.error("Invalid server " + server);
              return;
            }

            ircSocket = new WebSocket("ws://" + hp.host + ":" + hp.port + "/ircWebSocket");

            var connectTimeout = window.setTimeout(function() {
              console.log("Connect timeout fired");
              publishMsg.error("Timeout connecting to " + server);
              _disconnect();
            }, 5000);

            ircSocket.onopen = function() {
              console.log("Connection open");
              window.clearTimeout(connectTimeout);
              connected = true;
              public.send("NICK", nickname);
              public.send("USER", nickname, server, "smircd", nickname);
              currentNickname = nickname;
              publish("serverConnected", { host: hp.host, port: hp.port, nickname: nickname });
            };
            ircSocket.onclose = function() {
              console.log("Connection closed");
              ircSocket = null;
              _disconnect();
            };
            ircSocket.onmessage = function(msg) {
              console.log("Received [" + msg.data + "] from server");
              var parsed = _parseIrcCommandString(msg.data);
              if (!parsed.cmd) {
                publishMsg.error("Internal error: Unable to parse " + msg.data);
              }
              else {
                publish("receivedIrcMsg", parsed);
              }
            };
            ircSocket.onerror = function(err) {
              console.log(err);
            };
          },

          currentNickname: function() {
            return currentNickname;
          },

          send: function() {
            var cmd = _toIrcCommandString(Array.prototype.slice.apply(arguments));
            console.log("Sending [" + cmd + "] to server");
            if (ircSocket) {
              ircSocket.send(cmd);
            }
            else {
              publishMsg.error("Not connected, cannot send " + cmd);
            }
          },

          subscribeToMsg: function(cmdNames, callback) {
            var targetMsgs = { };
            $.each($.makeArray(cmdNames), function(idx, el) {
              targetMsgs[el] = true }
            );

            subscribe("receivedIrcMsg", function(parsed) {
              if (targetMsgs[parsed.cmd]) {
                try {
                  callback(parsed);
                } catch (err) {
                  console.error("Error in callback for " + parsed.cmd + ": " + err);
                }
              }
            });
          }
        };

        public.subscribeToMsg("PING", function() {
          public.send("PONG");
        });

        public.subscribeToMsg(["JOIN", "PART"], function(parsed) {
          var action = (parsed.cmd == "JOIN")? "joined" : "left";
          var actor = (parsed.prefix == currentNickname)? "You" : parsed.prefix;
          var channel = parsed.args[0];

          if (parsed.prefix == currentNickname) {
            publish((parsed.cmd == "JOIN")? "joinedChannel" : "leftChannel", channel);
          }

          publishMsg.event([actor, action, "channel", channel].join(" "));
        });

        return public;
      })();

      var publishMsg = (function() {
        var _publishMsg = function(msgType, msgText) {
          publish("showMsg", { type: msgType, text: msgText });
        };

        var _makePublisher = function(msgType, allowUnsafe) {
          allowUnsafe = allowUnsafe || false;
          return function(msg) {
            msg = allowUnsafe? msg : makeSafe(msg);
            var tmplArg = ($.type(msg) == 'string')?  { msg: msg } : msg;
            _publishMsg(msgType, tmpl(msgType + "MsgTmpl", tmplArg));
          };
        };

        return {
          system: _makePublisher("system", true),
          event: _makePublisher("event"),
          chat: _makePublisher("chat"),
          error: _makePublisher("error")
        };
      })();

      var userCommands = (function() {
        var cmds = { };
        $([
          [ "HELP", "[command]",
            "Display help",
            "Display available commands, or the usage of a specific command",
            function(input) {
              var cmd = firstToken(input);
              if (cmd) {
                var fn = cmds[cmd.toUpperCase()];
                if (fn) {
                  console.log("Showing help for " + cmd);
                  publishMsg.system(tmpl("commandHelpTmpl", fn.help));
                }
                else {
                  console.log("Help requested for invalid command " + cmd);
                  publishMsg.error("Can not show help for invalid command: " + cmd);
                }
              }
              else {
                console.log("Showing help");
                publishMsg.system(tmpl("helpTmpl", { cmds: cmds }));
              }
            } ],
          [ "CONNECT", "nickname [password] [@server]",
            "Connect to the IRC server",
            "Connect to the given IRC server. Password and server are optional, with a default server used if none is specified.",
            function(input) {
              var tokenAndRest = splitToken(input);
              var nickname = tokenAndRest[0];
              var server = null, password = null;

              if (!nickname) {
                console.log("Missing nickname param");
                publishMsg.error("Nickname is required");
                return;
              }

              while (tokenAndRest[1]) {
                tokenAndRest = splitToken(tokenAndRest[1]);
                if (tokenAndRest[0][0] == '@') {
                  server = tokenAndRest[0].substring(1);
                  if (!server) {
                    publishMsg.error("Empty server parameter");
                    return;
                  }
                  break;
                }
                else if (!password) {
                  password = tokenAndRest[0];
                }
                else {
                  publishMsg.error("Unexpected parameter " + tokenAndRest[0]);
                  return;
                }
              }

              ircServer.connect(server, nickname, password);
            } ],
          [ "JOIN", "channel",
            "Join a channel",
            "Join the specified channel",
            function(input) {
              var targetChannel = firstToken(input);
              if (targetChannel) {
                ircServer.send("JOIN", targetChannel);
              }
              else {
                publishMsg.error("Channel name is required");
              }
            } ],
          [ "PART", "[channel]",
            "Leave a channel",
            "Leave the specified channel, or the current channel if none is specified",
            function(input) {
              var targetChannel = firstToken(input) || channelManager.currentChannel();
              if (targetChannel) {
                ircServer.send("PART", targetChannel);
              }
              else {
                publishMsg.error("Not a memeber of any channel");
              }
            } ],
          [ "LIST", "[channel]",
            "List channel information",
            "List information about the specified channel, or all channels if none is specified",
            function(input) {
              var targetChannel = firstToken(input);
              if (targetChannel) {
                ircServer.send("LIST", targetChannel);
              }
              else {
                ircServer.send("LIST");
              }
            } ]
        ]).each(function(idx, cmdInfo) {
          var fn = cmdInfo[4];
          fn.help = {
            cmdName: cmdInfo[0].toUpperCase(),
            usage: cmdInfo[1],
            quick: cmdInfo[2],
            detailed: cmdInfo[3]
          };

          cmds[fn.help.cmdName] = fn;
        });

        return cmds;
      })();

      var userInputProcessor = (function() {
        return {
          process: function(input) {
            if (input.length == 0) { return; }
            if (input[0] == "/") {
              console.log("Processing user command");
              var tokenAndRest = splitToken(input);
              var cmd = tokenAndRest[0].substring(1).toUpperCase();
              if (userCommands[cmd]) {
                console.log("Invoking " + cmd + " command");
                userCommands[cmd](tokenAndRest[1])
              }
              else {
                console.log("User entered invalid command: " + cmd);
                publishMsg.error("Invalid command: " + cmd);
              }
            }
            else {
              console.log("Processing user message");
            }
          }
        };
      })();

      $('form').submit(function(evt) {
        try {
          $(evt.target).find('input').val(function(idx, currentVal) {
            userInputProcessor.process(currentVal);
            return '';
          });
        } catch (err) {
          publishMsg.error("Internal error: " + err);
        }

        return false;
      });

      // todo - more robust transcript management
      subscribe("showMsg", function(msg) {
          $(".transcript").append(msg.text).scrollTop($(".transcript").attr("scrollHeight"));
      });

      (function() {
        // Trigger animation on connect/disconnect/etc, but since the
        // animation happens asynch with respect to the events firing,
        // run everything through a queue to make sure one animation
        // sequence finishes before the next begins.
        var theQ = $({});
        var driveReveal = function(id, data) {
          var target = '#' + id;
          theQ.queue(function(driveQueue) {
            var stopAt = $(target).text(tmpl(id + 'Tmpl', data)).next();
            $(target).show('fast', function() {
              if (!$(this).next().not(stopAt).show('fast', arguments.callee).length) {
                driveQueue();
              }
            });
          });
        };

        var driveConceal = function(id) {
          var target = '#' + id;
          theQ.queue(function(driveQueue) {
            var stopAt = $(target).prev();
            $(target).parent().children().last().hide('fast', function() {
              if (!$(this).prev().not(stopAt).hide('fast', arguments.callee).length) {
                driveQueue();
              }
            });
          });
        };

        subscribe("serverConnected", function(data) {
          driveReveal('connectionInfo', data);
        });

        subscribe("serverDisconnected", function() {
          driveConceal('connectionInfo');
        });

        subscribe("currentChannelChanged", function(data) {
          if (data.previousChannel) {
            driveConceal('channelInfo');
          }

          if (data.channel) {
            driveReveal('channelInfo', data);
          }
        });
      })();

      ircServer.subscribeToMsg(ircServer.RC.ERR_NICKNAMEINUSE, function() {
        publishMsg.error("Nickname already in use");
      });

      var subscribeAndBuffer = function(startCode, dataCode, endCode, tmplName, dataFn) {
        var buffer = null, rc = ircServer.RC;
        ircServer.subscribeToMsg([rc[startCode], rc[dataCode], rc[endCode]], function(msg) {
          if (msg.cmd == rc[startCode]) {
            console.log("Buffering for " + tmplName);
            buffer = [];
          }
          else if (msg.cmd == rc[dataCode]) {
            var data = dataFn(msg);
            if (data) {
              buffer.push(data);
            }
          }
          else {
            console.log("Buffering complete for " + tmplName);
            if (buffer.length > 0) {
              var safeBuffer = makeSafe(buffer);
              publishMsg.system(tmpl(tmplName, { buffer: safeBuffer }));
            }

            buffer = null;
          }
        });
      };

      subscribeAndBuffer("RPL_MOTDSTART", "RPL_MOTD", "RPL_ENDOFMOTD", "motdTmpl", function(msg) {
        return (msg.args.length < 2)? null : msg.args[1];
      });

      subscribeAndBuffer("RPL_LISTSTART", "RPL_LIST", "RPL_LISTEND", "listTmpl", function(msg) {
        return (msg.args.length < 4)? null : {
          name: msg.args[1],
          count: msg.args[2],
          isMember: channelManager.isMember(msg.args[1])? '*' : ' ',
          topic: msg.args[3]
        };
      });

      ircServer.subscribeToMsg("PRIVMSG", function(msg) {
        var t  = msg.args[0];
        publish(t == ircServer.currentNickname()? "privateMessage" : "channelMessage", {
          msgSender: msg.prefix,
          msgTarget: t,
          message: msg.args[1]
        });
      });

      var getDate = function() {
        var pad = function(num) {
          return (num < 10)? "0" + num : num;
        };

        var d = new Date();
        return [d.getFullYear(), pad(d.getMonth() + 1), pad(d.getDate())].join('-') +
          ' ' +
          [pad(d.getHours()), pad(d.getMinutes())].join(':');
      };

      subscribe("privateMessage", function(evt) {
        console.log("Received private message");
        publishMsg.chat($.extend({}, evt, {
          msgDate: getDate(),
          msgType: 'private',
          msgSender: '*' + evt.msgSender + '*'
        }));
      });

      subscribe("channelMessage", function(evt) {
        console.log("Received message for channel " + evt.msgTarget);
        var forActiveChannel = (evt.msgTarget == channelManager.currentChannel());
        publishMsg.chat($.extend({}, evt, {
          msgDate: getDate(),
          msgType: forActiveChannel? 'activeChannel' : 'backgroundChannel',
          msgSender: forActiveChannel?
            evt.msgSender :
            evt.msgSender + "(" + evt.msgTarget + ")"
        }));
      });

    </script>
  </body>
</html>

